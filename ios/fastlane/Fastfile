# Fastfile - Deployment automation for Everyday Christian iOS app
# Documentation: https://docs.fastlane.tools

default_platform(:ios)

platform :ios do

  # ========================================
  # LANE: Beta Deployment (TestFlight)
  # ========================================
  # Usage: fastlane beta
  # Builds app, increments build number, uploads to TestFlight
  desc "Push a new beta build to TestFlight"
  lane :beta do
    # Ensure we're on a clean git state
    ensure_git_status_clean

    # Increment build number (keeps version the same)
    increment_build_number(
      xcodeproj: "Runner.xcodeproj"
    )

    # Build the app
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store"
      # Using automatic code signing - Xcode will manage certificates
    )

    # Upload to TestFlight
    upload_to_testflight(
      api_key_path: "fastlane/api_key.json", # Use API key authentication
      skip_waiting_for_build_processing: true, # Don't wait for Apple processing
      skip_submission: false, # Auto-submit for beta review
      distribute_external: false, # Only internal testers initially
      notify_external_testers: false
    )

    # Commit and push version bump
    commit_version_bump(
      message: "Bump build number for TestFlight beta [skip ci]",
      xcodeproj: "Runner.xcodeproj"
    )
    push_to_git_remote

    # Send success notification
    notification(
      title: "‚úÖ TestFlight Upload Complete",
      message: "Build uploaded successfully! Check App Store Connect for processing status."
    )
  end

  # ========================================
  # LANE: Release to App Store
  # ========================================
  # Usage: fastlane release
  # Builds app, uploads to App Store, submits for review
  desc "Deploy a new version to the App Store"
  lane :release do
    # Ensure we're on main branch
    ensure_git_branch(branch: 'main')
    ensure_git_status_clean

    # Optional: Run tests before release
    # run_tests(scheme: "Runner")

    # Increment version number (e.g., 1.0.0 -> 1.0.1)
    increment_version_number(
      bump_type: "patch", # or "minor", "major"
      xcodeproj: "Runner.xcodeproj"
    )

    # Build the app
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store"
    )

    # Upload to App Store Connect
    upload_to_app_store(
      skip_metadata: false, # Upload metadata changes
      skip_screenshots: false, # Upload screenshots if changed
      submit_for_review: true, # Auto-submit for review
      automatic_release: false, # Manual release after approval
      force: true, # Skip HTMl verification
      submission_information: {
        add_id_info_uses_idfa: false # Not using IDFA for ads
      }
    )

    # Commit version bump
    commit_version_bump(
      message: "Release version #{lane_context[SharedValues::VERSION_NUMBER]} [skip ci]",
      xcodeproj: "Runner.xcodeproj"
    )

    # Create git tag for release
    add_git_tag(
      tag: "v#{lane_context[SharedValues::VERSION_NUMBER]}"
    )

    push_to_git_remote(tags: true)

    notification(
      title: "üöÄ App Store Upload Complete",
      message: "Version #{lane_context[SharedValues::VERSION_NUMBER]} submitted for review!"
    )
  end

  # ========================================
  # LANE: Build Only (No Upload)
  # ========================================
  # Usage: fastlane build
  # Just builds the app without uploading
  desc "Build the iOS app without uploading"
  lane :build do
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      skip_package_ipa: false
    )

    notification(
      title: "‚úÖ Build Complete",
      message: "IPA file ready in build output directory"
    )
  end

  # ========================================
  # LANE: Capture Screenshots
  # ========================================
  # Usage: fastlane screenshots
  # Takes screenshots for all device sizes
  desc "Generate screenshots for App Store"
  lane :screenshots do
    capture_screenshots(
      scheme: "Runner",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      dark_mode: false
    )

    # Optionally upload to App Store Connect
    # upload_to_app_store(
    #   skip_binary_upload: true,
    #   skip_metadata: true
    # )
  end

  # ========================================
  # LANE: Update Metadata
  # ========================================
  # Usage: fastlane metadata
  # Updates App Store metadata without uploading a new build
  desc "Update App Store metadata only"
  lane :metadata do
    upload_to_app_store(
      api_key_path: "fastlane/api_key.json",
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true
    )

    notification(
      title: "üìù Metadata Updated",
      message: "App Store metadata updated successfully"
    )
  end

  # ========================================
  # LANE: Submit for Review
  # ========================================
  # Usage: fastlane submit
  # Submits the current build for App Store review
  desc "Submit current build for App Store review"
  lane :submit do
    upload_to_app_store(
      api_key_path: "fastlane/api_key.json",
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: false, # Upload metadata changes
      submit_for_review: true,
      automatic_release: false, # Manual release after approval
      run_precheck_before_submit: false, # Skip precheck (doesn't work with API key for IAPs)
      submission_information: {
        add_id_info_uses_idfa: false
      },
      force: true
    )

    notification(
      title: "üöÄ Submitted for Review",
      message: "Build 22 submitted to Apple for review!"
    )
  end

  # ========================================
  # LANE: Run Tests
  # ========================================
  # Usage: fastlane test
  # Runs all unit and UI tests
  desc "Run all tests"
  lane :test do
    run_tests(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      devices: ["iPhone 15 Pro"],
      clean: true
    )
  end

  # ========================================
  # LANE: Version Bump (Patch)
  # ========================================
  # Usage: fastlane bump
  # Increments patch version (1.0.0 -> 1.0.1)
  desc "Bump version number (patch)"
  lane :bump do
    ensure_git_status_clean

    increment_version_number(
      bump_type: "patch",
      xcodeproj: "Runner.xcodeproj"
    )

    version = get_version_number(xcodeproj: "Runner.xcodeproj")

    commit_version_bump(
      message: "Bump version to #{version} [skip ci]",
      xcodeproj: "Runner.xcodeproj"
    )

    push_to_git_remote

    UI.success("‚úÖ Version bumped to #{version}")
  end

  # ========================================
  # LANE: Match (Code Signing)
  # ========================================
  # Usage: fastlane sync_certificates
  # Syncs code signing certificates and profiles
  desc "Sync code signing certificates and profiles"
  lane :sync_certificates do
    match(
      type: "appstore",
      readonly: true, # Don't create new certificates
      app_identifier: "com.elev8tion.everydaychristian"
    )
  end

  # ========================================
  # ERROR HANDLING
  # ========================================
  error do |lane, exception|
    notification(
      title: "‚ùå Fastlane Error",
      message: "Lane '#{lane}' failed: #{exception.message}"
    )
  end
end
# Add this lane to query App Store Connect

lane :query_status do
  api_key = app_store_connect_api_key(
    key_id: "T9L7G79827",
    issuer_id: "e5761715-cdcf-42cb-b50e-09977a5c8279",
    key_filepath: "#{Dir.home}/private_keys/AuthKey_T9L7G79827.p8",
    duration: 1200,
    in_house: false
  )
  
  UI.header "Everyday Christian - App Store Status"
  
  # Get app info
  app = Spaceship::ConnectAPI::App.find("com.elev8tion.everydaychristian")
  
  if app
    UI.success "Found app: #{app.name}"
    UI.message "Bundle ID: #{app.bundle_id}"
    
    # Get versions
    live_version = app.get_live_app_store_version
    edit_version = app.get_edit_app_store_version
    
    if live_version
      UI.success "Live Version: #{live_version.version_string} (#{live_version.app_store_state})"
    end
    
    if edit_version
      UI.important "Edit Version: #{edit_version.version_string}"
      UI.important "Status: #{edit_version.app_store_state}"
      
      if edit_version.app_store_state.include?("REJECT")
        UI.error "‚ö†Ô∏è  VERSION REJECTED!"
        UI.error "Check Resolution Center for details"
      end
    end
    
    # Get builds
    UI.header "TestFlight Builds"
    builds = app.get_builds(limit: 10)
    builds.each do |build|
      UI.message "  Build #{build.version} (#{build.build_number}) - #{build.processing_state}"
    end
    
    # Get IAPs
    UI.header "In-App Purchases"
    begin
      subscription_groups = app.get_subscription_groups
      subscription_groups.each do |group|
        UI.message "Group: #{group.reference_name}"
        subscriptions = group.subscriptions
        subscriptions.each do |sub|
          UI.message "  - #{sub.product_id}: #{sub.state}"
        end
      end
    rescue => e
      UI.error "Could not fetch subscriptions: #{e.message}"
    end
    
  else
    UI.error "App not found!"
  end
end
lane :rejection_details do
  api_key = app_store_connect_api_key(
    key_id: "T9L7G79827",
    issuer_id: "e5761715-cdcf-42cb-b50e-09977a5c8279",
    key_filepath: "#{Dir.home}/private_keys/AuthKey_T9L7G79827.p8",
    duration: 1200
  )
  
  app = Spaceship::ConnectAPI::App.find("com.elev8tion.everydaychristian")
  
  UI.header "üì± Everyday Christian - Rejection Report"
  UI.message "Bundle ID: #{app.bundle_id}"
  UI.message ""
  
  # Get all versions
  edit_version = app.get_edit_app_store_version
  
  if edit_version
    UI.important "Version: #{edit_version.version_string}"
    UI.important "Status: #{edit_version.app_store_state}"
    UI.important "Created: #{edit_version.created_date}" if edit_version.created_date
    UI.message ""
    
    # Get subscription groups and products
    UI.header "üí∞ Subscription Configuration"
    begin
      groups = app.get_subscription_groups
      if groups.any?
        groups.each do |group|
          UI.message "Group: #{group.reference_name}"
          subs = group.subscriptions
          subs.each do |sub|
            UI.message "  ‚îî‚îÄ Product ID: #{sub.product_id}"
            UI.message "     State: #{sub.state}"
            UI.message "     Name: #{sub.name}" if sub.name
          end
        end
      else
        UI.error "‚ùå No subscription groups found!"
      end
    rescue => e
      UI.error "Error fetching subscriptions: #{e.message}"
    end
    
    UI.message ""
    UI.message "‚îÅ" * 60
    UI.important "To see detailed rejection reasons:"
    UI.important "1. Visit App Store Connect Resolution Center"
    UI.important "2. Or check your email for rejection notice from Apple"
    UI.message "‚îÅ" * 60
  else
    UI.error "No edit version found"
  end
end
#!/usr/bin/env ruby
# Query current subscription configuration via API

lane :query_subscriptions do
  api_key = app_store_connect_api_key(
    key_id: "T9L7G79827",
    issuer_id: "e5761715-cdcf-42cb-b50e-09977a5c8279",
    key_filepath: "#{Dir.home}/private_keys/AuthKey_T9L7G79827.p8",
    duration: 1200
  )

  UI.header "Querying Subscription Products"

  app = Spaceship::ConnectAPI::App.find("com.elev8tion.everydaychristian")

  # Get subscription groups using the correct API
  groups = Spaceship::ConnectAPI::SubscriptionGroup.all(app_id: app.id)

  if groups && groups.count > 0
    UI.success "Found #{groups.count} Subscription Group(s)"
    UI.message ""

    groups.each do |group|
      UI.header "Group: #{group.reference_name}"
      UI.message "Group ID: #{group.id}"
      UI.message ""

      # Get subscriptions in this group
      subs = Spaceship::ConnectAPI::Subscription.all(subscription_group_id: group.id)

      if subs && subs.count > 0
        subs.each do |sub|
          UI.important "‚îÅ‚îÅ‚îÅ Product: #{sub.product_id} ‚îÅ‚îÅ‚îÅ"
          UI.message "  Name: #{sub.name}" if sub.name
          UI.message "  State: #{sub.state}"
          UI.message "  Subscription Period: #{sub.subscription_period}" if sub.respond_to?(:subscription_period)

          # Get localizations
          begin
            locs = Spaceship::ConnectAPI::SubscriptionLocalization.all(subscription_id: sub.id)
            if locs && locs.count > 0
              UI.message "\n  üì± Localizations:"
              locs.each do |loc|
                UI.message "    ‚Ä¢ #{loc.locale}: #{loc.name}"
                UI.message "      Description: #{loc.description}" if loc.description
              end
            else
              UI.error "  ‚ö†Ô∏è  No localizations found!"
            end
          rescue => e
            UI.error "  ‚ö†Ô∏è  Could not fetch localizations: #{e.message}"
          end

          UI.message ""
        end
      else
        UI.error "No subscriptions found in this group!"
      end
    end
  else
    UI.error "No subscription groups found!"
  end
end

# ========================================
# LANE: Fix Subscription Localizations
# ========================================
# Usage: fastlane fix_subscription_localizations
# Updates subscription descriptions to show "150 messages monthly" instead of "Unlimited access"
desc "Fix subscription localizations to show correct message limits"
lane :fix_subscription_localizations do
  api_key = app_store_connect_api_key(
    key_id: "T9L7G79827",
    issuer_id: "e5761715-cdcf-42cb-b50e-09977a5c8279",
    key_filepath: "#{Dir.home}/private_keys/AuthKey_T9L7G79827.p8",
    duration: 1200
  )

  UI.header "üîß Fixing Subscription Localizations"

  app = Spaceship::ConnectAPI::App.find("com.elev8tion.everydaychristian")
  groups = Spaceship::ConnectAPI::SubscriptionGroup.all(app_id: app.id)

  # Correct descriptions
  descriptions = {
    "en-US" => "150 messages monthly, auto-renews monthly",
    "es-MX" => "150 mensajes mensuales, renovaci√≥n autom√°tica mensual",
    "es-ES" => "150 mensajes mensuales, renovaci√≥n autom√°tica mensual"
  }

  descriptions_yearly = {
    "en-US" => "150 messages monthly, auto-renews yearly",
    "es-MX" => "150 mensajes mensuales, renovaci√≥n autom√°tica anual",
    "es-ES" => "150 mensajes mensuales, renovaci√≥n autom√°tica anual"
  }

  groups.each do |group|
    UI.message "Processing group: #{group.reference_name}"

    subs = Spaceship::ConnectAPI::Subscription.all(subscription_group_id: group.id)

    subs.each do |sub|
      UI.important "Updating: #{sub.product_id}"

      # Determine if monthly or yearly
      is_yearly = sub.product_id.include?("yearly")
      correct_descriptions = is_yearly ? descriptions_yearly : descriptions

      # Get existing localizations
      locs = Spaceship::ConnectAPI::SubscriptionLocalization.all(subscription_id: sub.id)

      locs.each do |loc|
        locale = loc.locale
        current_desc = loc.description
        new_desc = correct_descriptions[locale]

        if new_desc && current_desc != new_desc
          UI.message "  Updating #{locale}: #{current_desc} ‚Üí #{new_desc}"

          begin
            # Update the localization
            loc.update(attributes: { description: new_desc })
            UI.success "  ‚úÖ Updated #{locale}"
          rescue => e
            UI.error "  ‚ùå Failed to update #{locale}: #{e.message}"
          end
        else
          UI.message "  ‚è≠  #{locale} already correct or not configured"
        end
      end
    end
  end

  UI.success "‚úÖ Subscription localizations updated!"
  UI.important "‚ö†Ô∏è  You may need to resubmit your app for these changes to take effect"
end
